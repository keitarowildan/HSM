//#include <Base64.h>

#include <Arduino.h>
#include <stm32f4xx.h>
#include <AESLib.h>
const int ARRAY_SIZE = 16;
byte aes_key[ARRAY_SIZE];
byte aes_decrypt_key[ARRAY_SIZE];
AESLib aesLib;
const int MAX_STRING_LENGTH = 128;
char plaintext[MAX_STRING_LENGTH];
#include <EEPROM.h>

#define EEPROM_SIZE 1600  // 100 keys * 16 bytes per key

void setupEEPROM() {
  EEPROM.begin();
}

bool addKeyToEEPROM(byte* key) {
  byte storedKey[16];
  bool isEmpty = true;

  for (int address = 0; address < 1600; address += 16) {
    isEmpty = true;
    for (int i = 0; i < 16; i++) {
      storedKey[i] = EEPROM.read(address + i);
      if (storedKey[i] != 0xFF) isEmpty = false; // Check if location is empty
    }

    if (memcmp(storedKey, key, 16) == 0) {
      Serial.println("Key already exists.");
      return false;
    }

    if (isEmpty) {
      for (int i = 0; i < 16; i++) {
        EEPROM.write(address + i, key[i]);
      }
      return true;
    }
  }
  rotateKeys(key);
  return true;
}


bool isEmpty(byte* key) {
  for (int i = 0; i < 16; i++) {
    if (key[i] != 0xFF) return false;
  }
  return true;
}
void rotateKeys(byte* newKey) {
  byte tempKey[16];
  for (int address = 0; address < 1600 - 16; address += 16) {
    for (int i = 0; i < 16; i++) {
      tempKey[i] = EEPROM.read(address + 16 + i);
      EEPROM.write(address + i, tempKey[i]);
    }
  }
  for (int i = 0; i < 16; i++) {
    EEPROM.write(1600 - 16 + i, newKey[i]);
  }
}



//char ciphertext[MAX_STRING_LENGTH];

int loopcount = 0;
unsigned int menu = 0;

char temp_for_decryption[256] = {0};
char ciphertext[512];

//byte aes_key[] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };
// AES Encryption Key

// General initialization vector (you must use your own IV's in production for full security!!!)
byte aes_iv[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

// Sample strings as generated by node.js server
String server_b64iv = "AAAAAAAAAAAAAAAAAAAAAAAA=="; // same as aes_iv  but in Base-64 form as received from server
String server_b64msg = "j0RFVdlKjYrwx17qzHdt40ZS4hxckx0riP4SNy21X3U="; // CBC/Zeropadding; same as aes_iv  but in Base-64 form as received from server

void print_key_iv() {
  Serial.print("AES IV: ");
  for (unsigned int i = 0; i < sizeof(aes_iv); i++) {
    Serial.print(aes_iv[i], DEC);
    if ((i + 1) < sizeof(aes_iv)) {
      Serial.print(",");
    }
  }

  Serial.println("");
}

String encrypt_impl(char * msg, byte iv[]) {
  int msgLen = strlen(msg);
  char encrypted[2 * msgLen] = {0};
  aesLib.encrypt64((const byte*)msg, msgLen, encrypted, aes_key, sizeof(aes_key), iv);
  return String(encrypted);
}

String decrypt_impl(char * msg, byte iv[]) {
  int msgLen = strlen(msg);
  char decrypted[msgLen] = {0}; // half may be enough
  aesLib.decrypt64(msg, msgLen, (byte*)decrypted, aes_decrypt_key, sizeof(aes_decrypt_key), iv);
  return String(decrypted);
}


void setup() {
  Serial.begin(115200);  // Initialize serial communication at 115200 baud rate
  delay(300);
  while(!Serial){;}
    randomSeed(analogRead(0)); // Seed the random number generator
    Serial.println("START CRYPTOGRAPHY");
      setupEEPROM();
  randomizeArray(); // Randomize the array
  printArray(); // Print the randomized array
  printMenu();           // Display the menu options
  printBase64();
}

void loop() {
  if (Serial.available() > 0) { // Check if data is available to read
    int option = Serial.parseInt(); // Read the option
    clearSerialBuffer();            // Clear any leftover characters in the buffer
    handleMenu(option);             // Handle the selected menu option
  }
}

void printMenu() {
  Serial.println("Select an option:");
  Serial.println("1. Encrypt");
  Serial.println("2. Decrypt");
  Serial.println("3. List SD Card Content");
  Serial.println("4. Reset");
}

void handleMenu(int option) {
  switch (option) {
    case 1:
      encryptData();
      break;
    case 2:
      decryptData();
      break;
    case 3:
      listSDCardContent();
      // [BUAT TITO] ISIII INI BUAT NGELIST ISI SD CARDNYA ADA APA AJA
      break;
    case 4:
      resetDevice();
      break;
    default:
      Serial.println("Invalid option. Please try again.");
      printMenu(); // Only reprint menu if the option was invalid
      return;
  }
  printMenu(); // Print the menu again after completing any valid action
}

void encryptData() {
  Serial.println("Enter the plaintext:");

  // Wait for user input from serial monitor
  while (Serial.available() == 0) {
    // Wait until data is available
  }

  // Read input string from serial monitor
  int bytesRead = Serial.readBytesUntil('\n', plaintext, MAX_STRING_LENGTH - 1);
  plaintext[bytesRead] = '\0'; // Null-terminate the string
  clearSerialBuffer();
  // Copy plaintext to temp_for_decryption
  strncpy(temp_for_decryption, plaintext, sizeof(temp_for_decryption) - 1);
  temp_for_decryption[sizeof(temp_for_decryption) - 1] = '\0'; // Ensure null-termination

  // Print the entered plaintext
  Serial.print("Entered plaintext: ");
  Serial.println(plaintext);
    aesLib.set_paddingmode(paddingMode::ZeroLength);  

  byte enc_iv_A[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  Serial.println("Encrypting plaintext using null-IV with ZeroLength padding");
  String encrypted1 = encrypt_impl((char*)plaintext, enc_iv_A);
  Serial.print("Encrypted(1): "); Serial.println(encrypted1);
  // [BUAT TITO] encrypted1 isinya ciphertext, ini disave
  print_key_iv();
}

void decryptData() {
  Serial.println("Enter key :");
  while (Serial.available() == 0) {
    // Wait until data is available
  }

  byte key[16];
  readKeyFromSerial(key);
  if (!addKeyToEEPROM(key)) {
    Serial.println("Key is used. Enter a new key:");
    return;
  }

  // Read the input from the Serial Monitor
  String encoded = Serial.readStringUntil('\n');
  
  // Remove trailing newline characters
  encoded.trim();

  // Allocate buffer for decoded data
  char buffer[16];  // Temporary buffer to hold decoded data

  // Decode Base64 string
  int decodedLength = base64_decode(buffer, encoded.c_str(), encoded.length());

  // Copy the decoded data to aes_decrypt_key
  memcpy(aes_decrypt_key, buffer, decodedLength);

  // Optionally print the decoded data for verification
  Serial.println("Decoded data:");
  for (int i = 0; i < decodedLength; i++) {
    Serial.print("0x");
    if (aes_decrypt_key[i] < 16) Serial.print("0");
    Serial.print(aes_decrypt_key[i], HEX);
    if (i < decodedLength - 1) Serial.print(", ");
  }
  Serial.println();  // Print newline to end the line

  clearSerialBuffer();
  Serial.println("Enter the ciphertext :");

  // Wait for user input from serial monitor
  while (Serial.available() == 0) {
    // Wait until data is available
  }

  // Read input string from serial monitor
  int bytesRead = Serial.readBytesUntil('\n', ciphertext , MAX_STRING_LENGTH - 1);
  ciphertext [bytesRead] = '\0'; // Null-terminate the string
  clearSerialBuffer();
  
  // Copy ciphertext  to temp_for_decryption
  strncpy(temp_for_decryption, ciphertext , sizeof(temp_for_decryption) - 1);
  temp_for_decryption[sizeof(temp_for_decryption) - 1] = '\0'; // Ensure null-termination

  // Print the entered ciphertext 
  Serial.print("Entered ciphertext : ");
  Serial.println(ciphertext);
  String for_decryption = String(temp_for_decryption);
  byte dec_iv_B[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  Serial.println("Decrypting using null-IV ZeroLength padding");
  String decrypted = decrypt_impl((char*)for_decryption.c_str(), dec_iv_B); // aes_iv fails here, incorrectly decoded...
  Serial.print("Cleartext: ");
  Serial.println(decrypted);
  Serial.println("\nIn first iteration this should work (using untouched dec_iv_B) ^^^");
}

void readKeyFromSerial(byte* key) {
  for (int i = 0; i < 16; i++) {
    while (Serial.available() == 0); // Wait for data
    key[i] = Serial.read();
  }
}

void listSDCardContent() {
  Serial.println("Listing SD Card content...");
  // Add your SD card listing code here
}

void resetDevice() {
  Serial.println("Resetting device...");
  NVIC_SystemReset();
}

void clearSerialBuffer() {
  while (Serial.available() > 0) {
    Serial.read();  // Read and discard any leftover characters
  }
}
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

void randomizeArray() {
  // Shuffle the array using the Fisher-Yates algorithm
  for (int i = 0; i < ARRAY_SIZE; ++i) {
    aes_key[i] = random(256);
  }
}


void printArray() {
  Serial.print("byte aes_key[] = { ");
  for (int i = 0; i < ARRAY_SIZE; ++i) {
    Serial.print("0x");
    if (aes_key[i] < 16) {
      Serial.print("0"); // Print leading zero for single-digit hex numbers
    }
    Serial.print(aes_key[i], HEX);
    if (i < ARRAY_SIZE - 1) {
      Serial.print(", ");
    }
  }
  Serial.println(" };");
}
void printBase64() {
  char encodedData[24]; // Enough space to encode 16 bytes
  int encodedLen = base64_encode(encodedData, (char*)aes_key, ARRAY_SIZE);
  Serial.print("Base64 encoded key: ");
  Serial.println(encodedData);
//  [BUAT TITO] encodedData isinya kunci AES dalam format base64, ini disave
}
