#include <Arduino.h>
#include <stm32f4xx.h>
#include <AESLib.h>

AESLib aesLib;
const int MAX_STRING_LENGTH = 128;
char plaintext[MAX_STRING_LENGTH];
//char ciphertext[MAX_STRING_LENGTH];

int loopcount = 0;
unsigned int menu = 0;

char cleartext[256] = {0};
char ciphertext[512];

byte aes_key[] = { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C };
// AES Encryption Key

// General initialization vector (you must use your own IV's in production for full security!!!)
byte aes_iv[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

// Sample strings as generated by node.js server
String server_b64iv = "AAAAAAAAAAAAAAAAAAAAAAAA=="; // same as aes_iv  but in Base-64 form as received from server
String server_b64msg = "j0RFVdlKjYrwx17qzHdt40ZS4hxckx0riP4SNy21X3U="; // CBC/Zeropadding; same as aes_iv  but in Base-64 form as received from server

void print_key_iv() {
  Serial.print("AES IV: ");
  for (unsigned int i = 0; i < sizeof(aes_iv); i++) {
    Serial.print(aes_iv[i], DEC);
    if ((i + 1) < sizeof(aes_iv)) {
      Serial.print(",");
    }
  }

  Serial.println("");
}

String encrypt_impl(char * msg, byte iv[]) {
  int msgLen = strlen(msg);
  char encrypted[2 * msgLen] = {0};
  aesLib.encrypt64((const byte*)msg, msgLen, encrypted, aes_key, sizeof(aes_key), iv);
  return String(encrypted);
}

String decrypt_impl(char * msg, byte iv[]) {
  int msgLen = strlen(msg);
  char decrypted[msgLen] = {0}; // half may be enough
  aesLib.decrypt64(msg, msgLen, (byte*)decrypted, aes_key, sizeof(aes_key), iv);
  return String(decrypted);
}


void setup() {
  Serial.begin(115200);  // Initialize serial communication at 115200 baud rate
  printMenu();           // Display the menu options
}

void loop() {
  if (Serial.available() > 0) { // Check if data is available to read
    int option = Serial.parseInt(); // Read the option
    clearSerialBuffer();            // Clear any leftover characters in the buffer
    handleMenu(option);             // Handle the selected menu option
  }
}

void printMenu() {
  Serial.println("Select an option:");
  Serial.println("1. Encrypt");
  Serial.println("2. Decrypt");
  Serial.println("3. List SD Card Content");
  Serial.println("4. Reset");
}

void handleMenu(int option) {
  switch (option) {
    case 1:
      encryptData();
      break;
    case 2:
      decryptData();
      break;
    case 3:
      listSDCardContent();
      break;
    case 4:
      resetDevice();
      break;
    default:
      Serial.println("Invalid option. Please try again.");
      printMenu(); // Only reprint menu if the option was invalid
      return;
  }
  printMenu(); // Print the menu again after completing any valid action
}

void encryptData() {
  Serial.println("Enter the plaintext:");

  // Wait for user input from serial monitor
  while (Serial.available() == 0) {
    // Wait until data is available
  }

  // Read input string from serial monitor
  int bytesRead = Serial.readBytesUntil('\n', plaintext, MAX_STRING_LENGTH - 1);
  plaintext[bytesRead] = '\0'; // Null-terminate the string
  clearSerialBuffer();
  // Copy plaintext to cleartext
  strncpy(cleartext, plaintext, sizeof(cleartext) - 1);
  cleartext[sizeof(cleartext) - 1] = '\0'; // Ensure null-termination

  // Print the entered plaintext
  Serial.print("Entered plaintext: ");
  Serial.println(plaintext);
    aesLib.set_paddingmode(paddingMode::ZeroLength);  

  byte enc_iv_A[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  Serial.println("Encrypting plaintext using null-IV with ZeroLength padding");
  String encrypted1 = encrypt_impl((char*)plaintext, enc_iv_A);
  Serial.print("Encrypted(1): "); Serial.println(encrypted1);
  print_key_iv();
}

void decryptData() {
  Serial.println("Enter the ciphertext :");

  // Wait for user input from serial monitor
  while (Serial.available() == 0) {
    // Wait until data is available
  }

  // Read input string from serial monitor
  int bytesRead = Serial.readBytesUntil('\n', ciphertext , MAX_STRING_LENGTH - 1);
  ciphertext [bytesRead] = '\0'; // Null-terminate the string
  clearSerialBuffer();
  // Copy ciphertext  to cleartext
  strncpy(cleartext, ciphertext , sizeof(cleartext) - 1);
  cleartext[sizeof(cleartext) - 1] = '\0'; // Ensure null-termination

  // Print the entered ciphertext 
  Serial.print("Entered ciphertext : ");
  Serial.println(ciphertext);
  String for_decryption = String(cleartext);
    byte dec_iv_B[N_BLOCK] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  Serial.println("Decrypting using null-IV ZeroLength padding");
  String decrypted = decrypt_impl((char*)for_decryption.c_str(), dec_iv_B); // aes_iv fails here, incorrectly decoded...
  Serial.print("Cleartext: ");
  Serial.println(decrypted);
  Serial.println("\nIn first iteration this should work (using untouched dec_iv_B) ^^^");
}

void listSDCardContent() {
  Serial.println("Listing SD Card content...");
  // Add your SD card listing code here
}

void resetDevice() {
  Serial.println("Resetting device...");
  NVIC_SystemReset();
}

void clearSerialBuffer() {
  while (Serial.available() > 0) {
    Serial.read();  // Read and discard any leftover characters
  }
}
